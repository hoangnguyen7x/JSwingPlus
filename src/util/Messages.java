package util;

/*
 * Created on 03-Nov-2003
 */

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.Properties;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.log4j.Logger;

/**
 * 
 * @author cs22
 * Class with utility methods for getting various values from properties files,
 * usually via ResourceBundles
 */
public final class Messages {

	private final static Logger LOGGER = Logger.getLogger (Messages.class);
	
	private static final String BUNDLE_NAME = "general";
	private static final ResourceBundle RESOURCE_BUNDLE = ResourceBundle.getBundle (BUNDLE_NAME);
	public static final String URL = "URL";
	public static final String DEFAULT = BUNDLE_NAME;
	public static final char ERROR_CHAR = '!';
	private static Map<String, Properties> propertyCache = new HashMap<String, Properties> ();

	/**
	 *
	 */
	private Messages() {}

	
	/**
	 * 
	 * @param bundle - a ResourceBundle to search
	 * @param key - the key to search for
	 * @return String value from given ResourceBundle for given key
	 */
	public static String getString (final ResourceBundle bundle, final String key) {
		if (key == null) {
			LOGGER.error ("Cannot query bundle with null key. Bundle: "+bundle);
			return ERROR_CHAR + "null key" + ERROR_CHAR;
		}
		
		if (bundle == null) {
			LOGGER.error ("Cannot query null bundle.");
			return ERROR_CHAR + key + ERROR_CHAR;
		}
		
		try {
			LOGGER.debug (key+"\t"+bundle.getString(key));
			return bundle.getString (key);
		} catch (final MissingResourceException mre) {
			LOGGER.error ("No key: "+key+" in "+bundle+" bundle.");
			return ERROR_CHAR + key + ERROR_CHAR;
		} catch (final NullPointerException npe) {
			// Shouldn't reach here now
			LOGGER.error ("NullPointerException for: "+key+" in "+bundle+" bundle.", npe);
			return ERROR_CHAR + key + ERROR_CHAR;
		}
	}
	
	/**
	 * 
	 * @param key - the key to search for
	 * @return value from default ResourceBundle for given key
	 */
	public static String getString (final String key) {
		return getString (RESOURCE_BUNDLE, key);
	}
	
	
	/**
	 * 
	 * @param klass - Class object whose simple name is used as first part of key
	 * @param partKey - String to use as second part of key
	 * @return String value from default ResourceBundle for given compound key
	 */
	public static String getString (final Class<?> klass, final String partKey) {
		if (klass != null) {
			final String key = new StringBuffer().append(klass.getSimpleName()).append('.').append(partKey).toString();
			LOGGER.debug ("COMPOUND KEY: "+key);
			return getString (key);
		}
		return null;
	}

	
	/**
	 * 
	 * @param bundleName - String representing path of ResourceBundle (e.g. 'javax.swing.messages')
	 * @param key - the key to search for
	 * @return String value from given ResourceBundle for given key
	 */
	public static String getString (final String bundleName, final String key) {
		final ResourceBundle bundle = ResourceBundle.getBundle (bundleName);
		return getString (bundle, key);
	}
	
	
	/**
	 * 
	 * @param bundleName - String representing path of ResourceBundle (e.g. 'javax.swing.messages')
	 * @param klass - Class object whose simple name is used as first part of key
	 * @param partKey - String to use as second part of key
	 * @return String value from derived ResourceBundle for given compound key
	 */
	public static String getString (final String bundleName, final Class<?> klass, final String partKey) {
		final String key = new StringBuffer().append(klass.getSimpleName()).append('.').append(partKey).toString();
		return getString (bundleName, key);
	}
	
	
	/**
	 * Return array of Strings, generated by splitting a value for a given key with a simple regular expression
	 * @param bundleName - String representing path of ResourceBundle (e.g. 'javax.swing.messages')
	 * @param key - the key to search for
	 * @param regex - regular expression to split value string with
	 * @return array of String[] holding parts of split value string
	 */
	public static String[] getSplitValueString (final String bundleName, final String key, final String regex) {
		final String value = getString (bundleName, key);
		return value.split (regex);
	}

	
	/**
	 * 
	 * @param bundleName - String representing path of ResourceBundle (e.g. 'javax.swing.messages')
	 * @return Set of String objects representing all keys in derived ResourceBundle
	 */
	public static Set<String> getKeys (final String bundleName) {
		return ResourceBundle.getBundle(bundleName).keySet();
	}
	
	
	/**
	 * 
	 * @param bundleName - String representing path of ResourceBundle (e.g. 'javax.swing.messages')
	 * @param prefix - prefix String of keys to search for
	 * @return Set of String objects representing all keys with given prefix in derived ResourceBundle
	 */
	public static List<String> getKeysWithPrefix (final String bundleName, final String prefix) {
		return getKeysWithRegex (bundleName, "^"+prefix);	
	}
	
	
	/**
	 * 
	 * @param bundleName - String representing path of ResourceBundle (e.g. 'javax.swing.messages')
	 * @param regex - String regular expression to match keys against
	 * @return Set of String objects representing all keys matching the given regex in derived ResourceBundle
	 */
	public static List<String> getKeysWithRegex (final String bundleName, final String regex) {
		final ResourceBundle bundle = ResourceBundle.getBundle (bundleName);
		final Set<String> keySet = bundle.keySet();
		final List<String> matchingKeyList = new ArrayList<String> ();
		final Pattern pattern = Pattern.compile (regex);
		final Matcher matcher = pattern.matcher (".....");

		for (String key : keySet) {
			matcher.reset (key);
			if (matcher.find()) {
				matchingKeyList.add (key);
			}
		}
		
		return (matchingKeyList.isEmpty() ? null : matchingKeyList);	
	}
	
	
	/**
	 * 
	 * @param bundleName - String representing path of ResourceBundle (e.g. 'javax.swing.messages')
	 * @return Properties file holding key/value pairs of derived ResourceBundle
	 */
	public static Properties makeProperties (final String bundleName) {
		return makeProperties (bundleName, true);
	}
	
	
	/**
	 * 
	 * @param bundleName - String representing path of ResourceBundle (e.g. 'javax.swing.messages')
	 * @param useCache - cache the resulting Properties object or not
	 * @return Properties file holding key/value pairs of derived ResourceBundle
	 */
	public static Properties makeProperties (final String bundleName, final boolean useCache) {
		Properties props = useCache ? propertyCache.get (bundleName) : null;
		
		if (props == null) {
			final ResourceBundle bundle = ResourceBundle.getBundle(bundleName);
			
			if (bundle != null) {
				props = new Properties ();
				final Set<String> keySet = bundle.keySet();
				
				for (String key : keySet) {
					final String value = bundle.getString (key);
					props.put(key, value);
				}
				
				if (useCache) {
					propertyCache.put (bundleName, props);
				}
			}
		}
		return props;
	}
	
	
	/**
	 * 
	 * @param bundleName - relative name of properties file
	 * @param relativeClass - class that the properties file is relative to
	 * @param useCache - cache or not
	 * @return Properties object containing keys/values in given bundle
	 */
	public static Properties makeProperties (final String bundleName, final Class<?> relativeClass, final boolean useCache) {
		final String packagePath = relativeClass.getPackage().getName();
		final String absBundleName = packagePath + "." + bundleName;
		return makeProperties (absBundleName, useCache);
	}
}